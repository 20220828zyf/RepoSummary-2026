ID,method_signature,func_file,method_code
0,structure_analsis.java.java_import_analyzer.JavaImportAnalyzer.__init__(self),structure_analsis/java/java_import_analyzer.py,"    def __init__(self):
        self.class_to_file: Dict[str, str] = {}
        self.package_classes: Dict[str, Set[str]] = defaultdict(set)
        self.all_classes: List[str] = []
        self.dependencies: Dict[str, Set[str]] = defaultdict(set)"
1,"structure_analsis.java.java_import_analyzer.JavaImportAnalyzer.analyze_project(self, project_root, output_file)",structure_analsis/java/java_import_analyzer.py,"    def analyze_project(self, project_root: str, output_file: str = ""file_adj_matrix.csv""):
        # 验证项目路径
        if not os.path.isdir(project_root):
            print(f""无效的项目目录: {project_root}"")
            return
        
        # 收集所有Java文件
        java_files = self._collect_java_files(project_root)
        
        # 第一遍解析：收集类信息
        for file_path in java_files:
            self._parse_class_info(file_path)
        
        # 第二遍解析：分析依赖关系
        for file_path in java_files:
            self._analyze_file_dependencies(file_path)
        
        # 生成邻接矩阵并写入CSV
        self._generate_adjacency_matrix(output_file)"
2,"structure_analsis.java.java_import_analyzer.JavaImportAnalyzer._collect_java_files(self, root_dir)",structure_analsis/java/java_import_analyzer.py,"    def _collect_java_files(self, root_dir: str) -> List[str]:
        java_files = []
        for root, _, files in os.walk(root_dir):
            for file in files:
                if file.endswith("".java""):
                    java_files.append(os.path.join(root, file))
        return java_files"
3,"structure_analsis.java.java_import_analyzer.JavaImportAnalyzer._parse_class_info(self, file_path)",structure_analsis/java/java_import_analyzer.py,"    def _parse_class_info(self, file_path: str):
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                source_code = file.read()
            
            tree = javalang.parse.parse(source_code)
            package_name = tree.package.name if tree.package else """"
            
            # 处理文件中的所有类声明
            for path, node in tree.filter(javalang.tree.ClassDeclaration):
                full_class_name = f""{package_name}.{node.name}"" if package_name else node.name
                self.all_classes.append(full_class_name)
                self.class_to_file[full_class_name] = file_path
                self.package_classes[package_name].add(full_class_name)
            
            # 处理接口声明
            for path, node in tree.filter(javalang.tree.InterfaceDeclaration):
                full_class_name = f""{package_name}.{node.name}"" if package_name else node.name
                self.all_classes.append(full_class_name)
                self.class_to_file[full_class_name] = file_path
                self.package_classes[package_name].add(full_class_name)
                
        except (javalang.parser.JavaSyntaxError, UnicodeDecodeError) as e:
            print(f""解析文件 {file_path} 时出错: {str(e)}"")"
4,"structure_analsis.java.java_import_analyzer.JavaImportAnalyzer._analyze_file_dependencies(self, file_path)",structure_analsis/java/java_import_analyzer.py,"    def _analyze_file_dependencies(self, file_path: str):
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                source_code = file.read()
            
            tree = javalang.parse.parse(source_code)
            package_name = tree.package.name if tree.package else """"
            
            # 获取当前文件的主类
            main_class = None
            for path, node in tree.filter((javalang.tree.ClassDeclaration, javalang.tree.InterfaceDeclaration)):
                if not main_class:
                    main_class = f""{package_name}.{node.name}"" if package_name else node.name
            
            if not main_class:
                return
            
            # 处理导入依赖
            for imp in tree.imports:
                imported = imp.path
                
                # 处理通配符导入
                if imp.wildcard:
                    imported_pkg = imported.rstrip('.*')
                    # 添加该包下的所有本地类
                    for cls in self.package_classes.get(imported_pkg, []):
                        self.dependencies[main_class].add(cls)
                # 处理单类导入
                else:
                    if imported in self.all_classes:
                        self.dependencies[main_class].add(imported)
            
            # 处理同包下的隐式导入
            if package_name in self.package_classes:
                for cls in self.package_classes[package_name]:
                    if cls != main_class:
                        self.dependencies[main_class].add(cls)
            
            # 处理完全限定名引用
            for _, node in tree.filter(javalang.tree.ReferenceType):
                # 尝试解析完全限定名
                if hasattr(node, 'name') and '.' in node.name:
                    possible_class = node.name
                    if possible_class in self.all_classes:
                        self.dependencies[main_class].add(possible_class)
            
        except (javalang.parser.JavaSyntaxError, UnicodeDecodeError) as e:
            print(f""分析依赖 {file_path} 时出错: {str(e)}"")"
5,"structure_analsis.java.java_import_analyzer.JavaImportAnalyzer._generate_adjacency_matrix(self, output_dir)",structure_analsis/java/java_import_analyzer.py,"    def _generate_adjacency_matrix(self, output_dir: str):
        if not self.all_classes:
            print(""未找到可分析的类"")
            return
        
        # 排序类名以确保顺序一致
        sorted_classes = sorted(set(self.all_classes))
        class_index = {cls: idx for idx, cls in enumerate(sorted_classes)}
        size = len(sorted_classes)
        
        # 初始化邻接矩阵
        adj_matrix = [[0] * size for _ in range(size)]
        
        # 填充依赖关系
        for src_class, deps in self.dependencies.items():
            if src_class not in class_index:
                continue
            src_idx = class_index[src_class]
            for dep_class in deps:
                if dep_class in class_index:
                    dep_idx = class_index[dep_class]
                    adj_matrix[src_idx][dep_idx] = 1
        
        # 写入CSV文件
        os.makedirs(output_dir, exist_ok=True)
        output_file = os.path.join(output_dir, ""file_adj_matrix.csv"")
        with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            
            # 写入标题行
            writer.writerow([''] + sorted_classes)
            
            # 写入矩阵行
            for i, cls in enumerate(sorted_classes):
                row = [cls] + adj_matrix[i]
                writer.writerow(row)
        
        print(f""邻接矩阵已写入: {output_file}"")"
6,structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer.__init__(self),structure_analsis/java/java_method_analyzer.py,"    def __init__(self):
        # 存储方法信息：ID -> (方法签名, 方法代码, 类名, 文件名, 起始行, 结束行)
        self.methods: Dict[int, Tuple[str, str, str, str, int, int]] = {}
        # 类名到方法ID的映射
        self.class_methods: Dict[str, Set[int]] = defaultdict(set)
        # 调用关系：调用者ID -> 被调用者ID集合
        self.call_relations: Dict[int, Set[int]] = defaultdict(set)
        # 存储文件AST树
        self.file_trees: Dict[str, Any] = {}
        # 当前方法ID计数器
        self.current_id = 1
        # 存储导入映射（每个文件一个）
        self.import_mapping: Dict[str, Dict[str, str]] = {}
        # 存储包名（按文件）
        self.package_names: Dict[str, str] = {}
        # 类继承/实现关系：类或接口 -> [父类/父接口...]
        self.class_hierarchy: Dict[str, List[str]] = defaultdict(list)
        # 方法签名到ID的映射
        self.signature_to_id: Dict[str, List[int]] = defaultdict(list)
        # 当前解析上下文（当前所在的方法ID）
        self.current_context: List[int] = []"
7,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer.analyze_project(self, project_root, output_dir)",structure_analsis/java/java_method_analyzer.py,"    def analyze_project(self, project_root: str, output_dir: str = "".""):
        if not os.path.isdir(project_root):
            print(f""无效的项目目录: {project_root}"")
            return

        java_files = self._collect_java_files(project_root)

        # 第一遍：收集类、继承关系和方法信息
        for file_path in java_files:
            self._parse_file_info(file_path)

        # 第二遍：分析调用关系
        for file_path in java_files:
            self._analyze_call_relations(file_path)

        # 输出
        os.makedirs(output_dir, exist_ok=True)
        self._write_method_csv(os.path.join(output_dir, ""method.csv""))
        self._generate_call_matrix(os.path.join(output_dir, ""method_adj_matrix.csv""))"
8,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._collect_java_files(self, root_dir)",structure_analsis/java/java_method_analyzer.py,"    def _collect_java_files(self, root_dir: str) -> List[str]:
        java_files = []
        for root, _, files in os.walk(root_dir):
            for file in files:
                if file.endswith("".java""):
                    java_files.append(os.path.join(root, file))
        return java_files"
9,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._parse_file_info(self, file_path)",structure_analsis/java/java_method_analyzer.py,"    def _parse_file_info(self, file_path: str):
        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
                source_code = file.read()
            
            tree = javalang.parse.parse(source_code)
            self.file_trees[file_path] = tree
            package_name = tree.package.name if tree.package else """"
            self.package_names[file_path] = package_name
            
            # 创建导入映射
            import_map: Dict[str, str] = {}
            for imp in tree.imports:
                if not imp.wildcard:
                    # import x.y.Z -> map[""Z""] = ""x.y.Z""
                    import_name = imp.path.split('.')[-1]
                    import_map[import_name] = imp.path
                else:
                    # 记录通配符导入包前缀（主要用于参考；精确匹配仍以类名为主）
                    import_map[imp.path.rstrip('.*')] = imp.path
            self.import_mapping[file_path] = import_map
            
            # 处理继承/实现关系
            for _, node in tree.filter(javalang.tree.ClassDeclaration):
                self._process_class_declaration(file_path, node, package_name)
            for _, node in tree.filter(javalang.tree.InterfaceDeclaration):
                self._process_interface_declaration(file_path, node, package_name)
            
            # 处理方法
            for _, node in tree.filter(javalang.tree.ClassDeclaration):
                full_class_name = f""{package_name}.{node.name}"" if package_name else node.name
                self._parse_class_methods(file_path, full_class_name, node)
            for _, node in tree.filter(javalang.tree.InterfaceDeclaration):
                full_class_name = f""{package_name}.{node.name}"" if package_name else node.name
                self._parse_class_methods(file_path, full_class_name, node)
                
        except (javalang.parser.JavaSyntaxError, UnicodeDecodeError) as e:
            print(f""解析文件 {file_path} 时出错: {str(e)}"")"
10,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_class_declaration(self, file_path, node, package_name)",structure_analsis/java/java_method_analyzer.py,"    def _process_class_declaration(self, file_path: str, node, package_name: str):
        full_class_name = f""{package_name}.{node.name}"" if package_name else node.name
        import_map = self.import_mapping.get(file_path, {})

        # 处理继承
        if node.extends:
            base_class = self._resolve_class_name(node.extends.name, package_name, import_map)
            if base_class:
                self.class_hierarchy[full_class_name].append(base_class)
        
        # 处理实现
        if node.implements:
            for impl in node.implements:
                interface_name = self._resolve_class_name(impl.name, package_name, import_map)
                if interface_name:
                    self.class_hierarchy[full_class_name].append(interface_name)"
11,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_interface_declaration(self, file_path, node, package_name)",structure_analsis/java/java_method_analyzer.py,"    def _process_interface_declaration(self, file_path: str, node, package_name: str):
        full_interface_name = f""{package_name}.{node.name}"" if package_name else node.name
        import_map = self.import_mapping.get(file_path, {})
        
        # 处理接口继承
        if node.extends:
            for ext in node.extends:
                base_interface = self._resolve_class_name(ext.name, package_name, import_map)
                if base_interface:
                    self.class_hierarchy[full_interface_name].append(base_interface)"
12,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._parse_class_methods(self, file_path, class_name, class_node)",structure_analsis/java/java_method_analyzer.py,"    def _parse_class_methods(self, file_path: str, class_name: str, class_node):
        # 处理类/接口中的所有方法
        for _, node in class_node.filter(javalang.tree.MethodDeclaration):
            self._record_method(file_path, class_name, node)
        # 处理构造函数
        for _, node in class_node.filter(javalang.tree.ConstructorDeclaration):
            self._record_method(file_path, class_name, node)"
13,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._record_method(self, file_path, class_name, method_node)",structure_analsis/java/java_method_analyzer.py,"    def _record_method(self, file_path: str, class_name: str, method_node):
        # 方法名（构造函数统一为 <init>）
        method_name = method_node.name
        if isinstance(method_node, javalang.tree.ConstructorDeclaration):
            method_name = ""<init>""
        
        # 参数列表：类型 + 名称
        params = []
        for param in method_node.parameters:
            param_type = self._get_type_name(param.type)
            param_name = getattr(param, 'name', '')
            # 统一格式：Type name；若缺失名称则仅保留类型
            if param_name:
                params.append(f""{param_type} {param_name}"")
            else:
                params.append(f""{param_type}"")
        param_str = "", "".join(params)
        
        # 签名（包含参数名）
        method_signature = f""{class_name}.{method_name}( {param_str} )""
        
        # 位置信息
        start_line = method_node.position.line if method_node.position else 0
        end_line = self._get_method_end_line(method_node, file_path)
        
        # 源码
        method_code = self._extract_method_code(file_path, start_line, end_line)
        
        # ID 分配与存储
        method_id = self.current_id
        self.current_id += 1
        
        self.methods[method_id] = (method_signature, method_code, class_name, file_path, start_line, end_line)
        self.class_methods[class_name].add(method_id)
        self.signature_to_id[method_signature].append(method_id)"
14,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._get_method_end_line(self, method_node, file_path)",structure_analsis/java/java_method_analyzer.py,"    def _get_method_end_line(self, method_node, file_path: str) -> int:
        
        start_line = method_node.position.line if method_node.position else 0
        if start_line <= 0:
            return 0

        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
                lines = f.readlines()
        except Exception:
            return start_line  # 兜底

        n = len(lines)
        i = start_line - 1  # 0-based

        brace_depth = 0
        in_single_line_comment = False
        in_block_comment = False

        def iterate_chars(line):
            nonlocal in_single_line_comment, in_block_comment
            in_string = False
            in_char = False
            escape = False
            j = 0
            L = len(line)
            while j < L:
                ch = line[j]
                nxt = line[j+1] if j+1 < L else ''

                # 行注释
                if not in_string and not in_char and not in_block_comment and ch == '/' and nxt == '/':
                    in_single_line_comment = True
                    break
                # 块注释开始
                if not in_string and not in_char and not in_block_comment and ch == '/' and nxt == '*':
                    in_block_comment = True
                    j += 2
                    continue
                # 块注释结束
                if in_block_comment and ch == '*' and nxt == '/':
                    in_block_comment = False
                    j += 2
                    continue

                if in_block_comment:
                    j += 1
                    continue

                # 字符串
                if not in_char and ch == '""' and not in_string:
                    in_string = True
                    escape = False
                    j += 1
                    continue
                elif in_string:
                    if ch == '\\' and not escape:
                        escape = True
                    elif ch == '""' and not escape:
                        in_string = False
                    else:
                        escape = False
                    j += 1
                    continue

                # 字符字面量
                if not in_string and ch == ""'"" and not in_char:
                    in_char = True
                    escape = False
                    j += 1
                    continue
                elif in_char:
                    if ch == '\\' and not escape:
                        escape = True
                    elif ch == ""'"" and not escape:
                        in_char = False
                    else:
                        escape = False
                    j += 1
                    continue

                # 正常字符
                yield ch
                j += 1

        # 第一阶段：查找 '{' 或 ';'
        found_open_brace = False
        while i < n:
            line = lines[i]
            in_single_line_comment = False
            for ch in iterate_chars(line):
                if in_single_line_comment:
                    break
                if ch == '{':
                    found_open_brace = True
                    brace_depth = 1
                    break
                if ch == ';':
                    # 无方法体声明，以此行为结束
                    return i + 1
            if found_open_brace:
                break
            i += 1

        if not found_open_brace:
            # 没找到 '{' 也没找到 ';'，兜底
            return start_line

        # 第二阶段：括号平衡，直到归零
        while i < n:
            line = lines[i]
            in_single_line_comment = False
            for ch in iterate_chars(line):
                if in_single_line_comment:
                    break
                if ch == '{':
                    brace_depth += 1
                elif ch == '}':
                    brace_depth -= 1
                    if brace_depth == 0:
                        return i + 1
            i += 1

        # 文件结束仍未归零，兜底返回最后一行
        return n"
15,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._extract_method_code(self, file_path, start_line, end_line)",structure_analsis/java/java_method_analyzer.py,"    def _extract_method_code(self, file_path: str, start_line: int, end_line: int) -> str:
        """"""按行号提取方法代码；若 end_line < start_line，则只取 start_line 那一行避免空串。""""""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
                lines = file.readlines()
            if start_line <= 0:
                return """"
            if end_line <= 0 or end_line < start_line:
                end_line = start_line
            start_idx = max(0, min(start_line - 1, len(lines) - 1))
            end_idx = max(start_idx, min(end_line - 1, len(lines) - 1))
            return ''.join(lines[start_idx:end_idx + 1])
        except Exception as e:
            print(f""提取方法代码出错: {str(e)}"")
            return """""
16,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._analyze_call_relations(self, file_path)",structure_analsis/java/java_method_analyzer.py,"    def _analyze_call_relations(self, file_path: str):
        try:
            tree = self.file_trees[file_path]
            package_name = self.package_names[file_path]
            import_map = self.import_mapping[file_path]
            
            # 遍历AST中的所有节点
            for _, node in tree:
                # 设置当前上下文
                self._update_context(file_path, getattr(node, 'position', None))
                
                # 方法调用
                if isinstance(node, javalang.tree.MethodInvocation):
                    self._process_method_invocation(file_path, node, package_name, import_map)
                
                # 构造函数调用
                elif isinstance(node, javalang.tree.ClassCreator):
                    self._process_constructor_call(file_path, node, package_name, import_map)
                
                # 方法引用
                elif isinstance(node, javalang.tree.MethodReference):
                    self._process_method_reference(file_path, node, package_name, import_map)
                
                # Lambda 表达式
                elif isinstance(node, javalang.tree.LambdaExpression):
                    self._process_lambda_expression(file_path, node, package_name, import_map)
                
                # 显式构造函数调用（super()/this()）
                elif isinstance(node, javalang.tree.ExplicitConstructorInvocation):
                    self._process_explicit_constructor(file_path, node, package_name, import_map)
                
                # 链式调用（粗略处理）
                elif isinstance(node, javalang.tree.MemberReference):
                    if hasattr(node, 'qualifier') and isinstance(node.qualifier, javalang.tree.MemberReference):
                        self._process_chained_call(file_path, node, package_name, import_map)
            
        except Exception as e:
            print(f""分析调用关系时出错: {file_path} - {str(e)}"")"
17,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._update_context(self, file_path, position)",structure_analsis/java/java_method_analyzer.py,"    def _update_context(self, file_path: str, position):
        """"""根据位置更新当前解析上下文""""""
        if not position:
            self.current_context = []
            return
        
        line = position.line
        
        # 查找包含当前行的方法
        for method_id, (_, _, _, _, start, end) in self.methods.items():
            if start <= line <= end:
                self.current_context = [method_id]
                return
        
        self.current_context = []"
18,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_method_invocation(self, file_path, node, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _process_method_invocation(self, file_path: str, node, package_name: str, import_map: Dict[str, str]):
        if not self.current_context:
            return
        
        caller_id = self.current_context[0]
        method_name = node.member
        
        # 解析目标类
        target_class = None
        if node.qualifier:
            qualifier = node.qualifier
            if isinstance(qualifier, str):
                if qualifier == ""this"":
                    target_class = self.methods[caller_id][2]
                else:
                    target_class = self._resolve_class_name(qualifier, package_name, import_map)
            elif hasattr(qualifier, 'name'):
                target_class = self._resolve_class_name(qualifier.name, package_name, import_map)
            elif hasattr(qualifier, 'type'):
                target_class = self._resolve_class_name(self._get_type_name(qualifier.type), package_name, import_map)
        else:
            # 无限定符：使用上下文类
            target_class = self._find_context_class(file_path, node.position)
        
        if not target_class:
            return
        
        # 获取参数类型
        arg_types: List[Optional[str]] = []
        for arg in node.arguments:
            arg_type = self._infer_expression_type(arg)
            if arg_type == ""this"":
                arg_type = self.methods[caller_id][2]
            if arg_type:
                arg_types.append(arg_type)
        
        # 查找匹配的方法
        callee_ids = self._find_matching_methods(target_class, method_name, arg_types)
        
        # 记录调用关系
        for callee_id in callee_ids:
            self.call_relations[caller_id].add(callee_id)"
19,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_constructor_call(self, file_path, node, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _process_constructor_call(self, file_path: str, node, package_name: str, import_map: Dict[str, str]):
        if not self.current_context:
            return
        
        caller_id = self.current_context[0]
        
        # 解析构造函数所属的类
        class_type = node.type
        class_name = self._get_type_name(class_type)
        target_class = self._resolve_class_name(class_name, package_name, import_map)
        
        if not target_class:
            return
        
        # 获取参数类型
        arg_types: List[Optional[str]] = []
        if node.arguments:
            for arg in node.arguments:
                t = self._infer_expression_type(arg)
                if t == ""this"":
                    t = self.methods[caller_id][2]
                if t:
                    arg_types.append(t)
        
        # 查找构造函数
        callee_ids = self._find_matching_methods(target_class, ""<init>"", arg_types)
        
        # 记录调用关系
        for callee_id in callee_ids:
            self.call_relations[caller_id].add(callee_id)"
20,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_method_reference(self, file_path, node, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _process_method_reference(self, file_path: str, node, package_name: str, import_map: Dict[str, str]):
        if not self.current_context:
            return
        
        caller_id = self.current_context[0]
        method_name = node.method
        
        # 解析方法所属的类
        target_class = None
        if node.expression:
            expr_type = self._infer_expression_type(node.expression)
            if expr_type == ""this"":
                expr_type = self.methods[caller_id][2]
            if expr_type:
                target_class = self._resolve_class_name(expr_type, package_name, import_map)
        
        if not target_class:
            return
        
        # 查找匹配的方法
        callee_ids = self._find_matching_methods(target_class, method_name, [])
        
        # 记录调用关系
        for callee_id in callee_ids:
            self.call_relations[caller_id].add(callee_id)"
21,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_lambda_expression(self, file_path, node, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _process_lambda_expression(self, file_path: str, node, package_name: str, import_map: Dict[str, str]):
        """"""处理 Lambda 表达式中的方法调用""""""
        outer_context = self.current_context.copy()
        
        if node.body:
            if isinstance(node.body, javalang.tree.MethodInvocation):
                self._process_method_invocation(file_path, node.body, package_name, import_map)
            elif isinstance(node.body, javalang.tree.StatementExpression):
                if isinstance(node.body.expression, javalang.tree.MethodInvocation):
                    self._process_method_invocation(file_path, node.body.expression, package_name, import_map)
            elif isinstance(node.body, javalang.tree.BlockStatement):
                for stmt in node.body.statements or []:
                    if isinstance(stmt, javalang.tree.StatementExpression):
                        if isinstance(stmt.expression, javalang.tree.MethodInvocation):
                            self._process_method_invocation(file_path, stmt.expression, package_name, import_map)
        
        self.current_context = outer_context"
22,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_explicit_constructor(self, file_path, node, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _process_explicit_constructor(self, file_path: str, node, package_name: str, import_map: Dict[str, str]):
        """"""处理显式构造函数调用（如 super() 或 this()）""""""
        if not self.current_context:
            return
        
        caller_id = self.current_context[0]
        _, _, class_name, _, _, _ = self.methods[caller_id]
        
        if node.type == 'super':
            if class_name in self.class_hierarchy:
                parent_classes = self.class_hierarchy[class_name]
                for parent in parent_classes:
                    arg_types = []
                    for arg in node.arguments or []:
                        t = self._infer_expression_type(arg)
                        if t == ""this"":
                            t = class_name
                        if t:
                            arg_types.append(t)
                    callee_ids = self._find_matching_methods(parent, ""<init>"", arg_types)
                    for callee_id in callee_ids:
                        self.call_relations[caller_id].add(callee_id)
        else:
            arg_types = []
            for arg in node.arguments or []:
                t = self._infer_expression_type(arg)
                if t == ""this"":
                    t = class_name
                if t:
                    arg_types.append(t)
            callee_ids = self._find_matching_methods(class_name, ""<init>"", arg_types)
            for callee_id in callee_ids:
                self.call_relations[caller_id].add(callee_id)"
23,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._process_chained_call(self, file_path, node, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _process_chained_call(self, file_path: str, node, package_name: str, import_map: Dict[str, str]):
        """"""处理链式方法调用（非常简化的推断）""""""
        if not self.current_context:
            return
        
        caller_id = self.current_context[0]
        
        # 递归处理链式调用的每个部分
        chain: List[str] = []
        current = node
        while current and isinstance(current, javalang.tree.MemberReference):
            chain.insert(0, current.member)
            current = getattr(current, 'qualifier', None) if hasattr(current, 'qualifier') else None
        
        # 解析链的起点
        target_class = None
        if isinstance(current, javalang.tree.MemberReference):
            if current.member == ""this"":
                target_class = self.methods[caller_id][2]
            else:
                target_class = self._resolve_class_name(current.member, package_name, import_map)
        elif hasattr(current, 'type'):
            target_class = self._resolve_class_name(self._get_type_name(current.type), package_name, import_map)
        
        if not target_class:
            return
        
        # 处理链中的每个方法调用
        for method_name in chain:
            callee_ids = self._find_matching_methods(target_class, method_name, [])
            if callee_ids:
                return_type = self._get_method_return_type(callee_ids[0])
                if return_type:
                    target_class = self._resolve_class_name(return_type, package_name, import_map) or target_class
                for callee_id in callee_ids:
                    self.call_relations[caller_id].add(callee_id)"
24,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._get_method_return_type(self, method_id)",structure_analsis/java/java_method_analyzer.py,"    def _get_method_return_type(self, method_id: int) -> Optional[str]:
        """"""获取方法的返回类型（简化近似）""""""
        signature = self.methods[method_id][0]
        match = re.match(r"".*?\.(\w+)\((.*?)\)"", signature)
        if match:
            method_name = match.group(1)
            if method_name == ""<init>"":
                return self.methods[method_id][2]
            else:
                return self.methods[method_id][2]
        return None"
25,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._infer_expression_type(self, expr)",structure_analsis/java/java_method_analyzer.py,"    def _infer_expression_type(self, expr) -> Optional[str]:
        """"""推断表达式类型（简化）""""""
        if isinstance(expr, javalang.tree.Literal):
            if ""'"" in expr.value or '""' in expr.value:
                return ""String""
            elif '.' in expr.value:
                return ""double""
            elif expr.value.isdigit():
                return ""int""
            elif expr.value in ['true', 'false']:
                return ""boolean""
        
        elif isinstance(expr, javalang.tree.MemberReference):
            return expr.member
        
        elif isinstance(expr, javalang.tree.This):
            return ""this""
        
        elif isinstance(expr, javalang.tree.MethodInvocation):
            return self._infer_method_return_type(expr)
        
        elif hasattr(expr, 'type'):
            return self._get_type_name(expr.type)
        
        return None"
26,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._infer_method_return_type(self, method_invocation)",structure_analsis/java/java_method_analyzer.py,"    def _infer_method_return_type(self, method_invocation) -> Optional[str]:
        """"""推断方法调用的返回类型（非常简化）""""""
        if method_invocation.qualifier:
            qualifier = method_invocation.qualifier
            if isinstance(qualifier, str):
                return qualifier
            elif hasattr(qualifier, 'name'):
                return qualifier.name
        return None"
27,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._resolve_class_name(self, name, package_name, import_map)",structure_analsis/java/java_method_analyzer.py,"    def _resolve_class_name(self, name: str, package_name: str, import_map: Dict[str, str]) -> Optional[str]:
        """"""解析类名到完全限定名（基于当前文件 import_map 与已知类集合）""""""
        if '.' in name and name in self.class_methods:
            return name
        
        if name in import_map:
            return import_map[name]
        
        full_name = f""{package_name}.{name}"" if package_name else name
        if full_name in self.class_methods:
            return full_name
        
        java_lang_name = f""java.lang.{name}""
        if java_lang_name in self.class_methods:
            return java_lang_name
        
        for cls in self.class_methods:
            if cls.endswith(f"".{name}""):
                return cls
        
        return None"
28,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._find_context_class(self, file_path, position)",structure_analsis/java/java_method_analyzer.py,"    def _find_context_class(self, file_path: str, position) -> Optional[str]:
        """"""根据位置查找上下文类（使用当前行所在的方法的类名）""""""
        if not position:
            return None
        for _, (_, _, class_name, _, start, end) in self.methods.items():
            if start <= position.line <= end:
                return class_name
        return None"
29,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._find_matching_methods(self, class_name, method_name, arg_types)",structure_analsis/java/java_method_analyzer.py,"    def _find_matching_methods(self, class_name: str, method_name: str, arg_types: List[str]) -> List[int]:
        """"""查找匹配的方法，考虑参数类型（简化）""""""
        method_ids: List[int] = []
        
        if class_name in self.class_methods:
            for method_id in self.class_methods[class_name]:
                signature = self.methods[method_id][0]
                if self._match_signature(signature, method_name, arg_types):
                    method_ids.append(method_id)
        
        if class_name in self.class_hierarchy:
            for parent in self.class_hierarchy[class_name]:
                parent_methods = self._find_matching_methods(parent, method_name, arg_types)
                method_ids.extend(parent_methods)
        
        return method_ids"
30,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._match_signature(self, signature, method_name, arg_types)",structure_analsis/java/java_method_analyzer.py,"    def _match_signature(self, signature: str, method_name: str, arg_types: List[str]) -> bool:
        """"""检查方法签名是否匹配（非常简化）""""""
        match = re.match(r"".*?\.(\w+)\((.*?)\)"", signature)
        if not match:
            return False
        
        sig_method_name = match.group(1)
        sig_params = match.group(2)
        
        if sig_method_name != method_name and not (sig_method_name == ""<init>"" and method_name == ""<init>""):
            return False
        
        # 允许签名里出现 ""Type name""；只取类型（第一个空格前或泛型整体）来对比
        def extract_type(p: str) -> str:
            p = p.strip()
            # 处理形如 ""List<String> ids"" 或 ""Map<K, V> m""
            # 简单规则：按空格切，取第一段作为类型
            return p.split()[0] if p else """"
        
        sig_param_list_raw = [p.strip() for p in sig_params.split(',')] if sig_params else []
        sig_param_types = [extract_type(p) for p in sig_param_list_raw if p != """"]
        
        if len(sig_param_types) != len(arg_types):
            return False
        
        primitive_map = {
            ""int"": ""Integer"",
            ""long"": ""Long"",
            ""double"": ""Double"",
            ""float"": ""Float"",
            ""boolean"": ""Boolean"",
            ""char"": ""Character"",
            ""byte"": ""Byte"",
            ""short"": ""Short""
        }
        for i, param_type in enumerate(arg_types):
            if not param_type:
                continue
            sig_t = sig_param_types[i]
            if sig_t == param_type:
                continue
            if param_type in primitive_map and sig_t == primitive_map[param_type]:
                continue
            if sig_t in primitive_map and primitive_map[sig_t] == param_type:
                continue
            if sig_t.endswith(f"".{param_type}"") or param_type.endswith(f"".{sig_t}""):
                continue
            return False
        
        return True"
31,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._get_type_name(self, type_node)",structure_analsis/java/java_method_analyzer.py,"    def _get_type_name(self, type_node) -> str:
        """"""获取类型名称，处理泛型（仅保留主类型名与泛型参数的主类型名）""""""
        if isinstance(type_node, javalang.tree.ReferenceType):
            base_name = '.'.join(type_node.name) if isinstance(type_node.name, list) else type_node.name
            if type_node.arguments:
                arg_names = []
                for arg in type_node.arguments:
                    if hasattr(arg, 'type') and arg.type is not None:
                        arg_names.append(self._get_type_name(arg.type))
                    else:
                        arg_names.append(""?"")
                return f""{base_name}<{', '.join(arg_names)}>""
            return base_name
        elif hasattr(type_node, 'name'):
            return type_node.name
        return """""
32,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._write_method_csv(self, output_file)",structure_analsis/java/java_method_analyzer.py,"    def _write_method_csv(self, output_file: str):
        """"""写入方法信息到 CSV""""""
        with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['ID', 'method_signature', 'method_code', 'class_name', 'file_path', 'start_line', 'end_line'])
            for method_id, (signature, code, class_name, file_path, start_line, end_line) in self.methods.items():
                clean_code = code.replace('\n', '\\n').replace('\r', '\\r')
                writer.writerow([method_id, signature, clean_code, class_name, file_path, start_line, end_line])
        print(f""方法信息已写入: {output_file}"")"
33,"structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._generate_call_matrix(self, output_file)",structure_analsis/java/java_method_analyzer.py,"    def _generate_call_matrix(self, output_file: str):
        """"""生成调用关系邻接矩阵""""""
        if not self.methods:
            print(""未找到可分析的方法"")
            return
        
        method_ids = sorted(self.methods.keys())
        id_index = {method_id: idx for idx, method_id in enumerate(method_ids)}
        size = len(method_ids)
        
        adj_matrix = [[0] * size for _ in range(size)]
        
        for caller_id, callee_ids in self.call_relations.items():
            if caller_id in id_index:
                caller_idx = id_index[caller_id]
                for callee_id in callee_ids:
                    if callee_id in id_index:
                        callee_idx = id_index[callee_id]
                        adj_matrix[caller_idx][callee_idx] = 1
        
        with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['Caller/Callee'] + [str(mid) for mid in method_ids])
            for i, method_id in enumerate(method_ids):
                row = [str(method_id)] + adj_matrix[i]
                writer.writerow(row)
        print(f""方法调用邻接矩阵已写入: {output_file}"")"
34,structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._get_method_end_line.iterate_chars(line),structure_analsis/java/java_method_analyzer.py,"        def iterate_chars(line):
            nonlocal in_single_line_comment, in_block_comment
            in_string = False
            in_char = False
            escape = False
            j = 0
            L = len(line)
            while j < L:
                ch = line[j]
                nxt = line[j+1] if j+1 < L else ''

                # 行注释
                if not in_string and not in_char and not in_block_comment and ch == '/' and nxt == '/':
                    in_single_line_comment = True
                    break
                # 块注释开始
                if not in_string and not in_char and not in_block_comment and ch == '/' and nxt == '*':
                    in_block_comment = True
                    j += 2
                    continue
                # 块注释结束
                if in_block_comment and ch == '*' and nxt == '/':
                    in_block_comment = False
                    j += 2
                    continue

                if in_block_comment:
                    j += 1
                    continue

                # 字符串
                if not in_char and ch == '""' and not in_string:
                    in_string = True
                    escape = False
                    j += 1
                    continue
                elif in_string:
                    if ch == '\\' and not escape:
                        escape = True
                    elif ch == '""' and not escape:
                        in_string = False
                    else:
                        escape = False
                    j += 1
                    continue

                # 字符字面量
                if not in_string and ch == ""'"" and not in_char:
                    in_char = True
                    escape = False
                    j += 1
                    continue
                elif in_char:
                    if ch == '\\' and not escape:
                        escape = True
                    elif ch == ""'"" and not escape:
                        in_char = False
                    else:
                        escape = False
                    j += 1
                    continue

                # 正常字符
                yield ch
                j += 1"
35,structure_analsis.java.java_method_analyzer.JavaMethodAnalyzer._match_signature.extract_type(p),structure_analsis/java/java_method_analyzer.py,"        def extract_type(p: str) -> str:
            p = p.strip()
            # 处理形如 ""List<String> ids"" 或 ""Map<K, V> m""
            # 简单规则：按空格切，取第一段作为类型
            return p.split()[0] if p else """""
